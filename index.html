<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Christmas Traditions Word Search</title>

<style>
:root{
  --tile:46px;
  --gap:10px;
  --border:#d9d9d9;
  --selected:#cfe8ff;
  --found:#bfe6c6;
  --primary:#bfe6c6;
  --secondary:#e7e7e7;
  --max:1100px;
}

body{
  margin:0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

.wrap{
  max-width:var(--max);
  margin:0 auto;
  padding:28px 18px 40px;
}

h1{ margin:0 0 6px; font-size:44px; }
.sub{ margin:0 0 18px; color:#444; font-size:18px; }

.layout{
  display:flex;
  gap:26px;
  align-items:flex-start;
}

/* STACK ON MOBILE */
@media (max-width: 768px){
  .layout{
    flex-direction: column;
    align-items: center;
  }
}

.grid{
  display:grid;
  gap:var(--gap);
  justify-content:center;
  user-select:none;
}

.tile{
  width:var(--tile);
  height:var(--tile);
  border:1px solid var(--border);
  border-radius:10px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:800;
  font-size:20px;
  cursor:pointer;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}

.tile.sel{ background:var(--selected); }
.tile.found{ background:var(--found); }

.side{ width:320px; }

@media (max-width: 768px){
  .side{ width:100%; max-width:520px; }
}

.side h2{ margin:6px 0 12px; font-size:28px; }

.chips{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  margin-bottom:14px;
}

.chip{
  padding:10px 14px;
  border-radius:999px;
  border:1px solid #d0d0d0;
  font-weight:800;
  font-size:14px;
}

.chip.found{
  background:var(--found);
  border-color:transparent;
}

.controls{
  display:flex;
  gap:12px;
  margin:12px 0;
}

button{
  border:0;
  border-radius:10px;
  padding:12px 16px;
  font-weight:800;
  font-size:16px;
  cursor:pointer;
}

.primary{ background:var(--primary); }
.secondary{ background:#d7efe3; }

.status{
  font-size:18px;
  font-weight:900;
}

/* SMALL PHONES: MAKE THE GRID FIT (NO LEFT CUTOFF) */
@media (max-width: 520px){
  :root{
    --tile:28px;  /* <-- key change: fits 14 cols */
    --gap:4px;
  }
  h1{ font-size:34px; }
  .sub{ font-size:16px; }
  .tile{ font-size:14px; }
}
</style>
</head>

<body>
<div class="wrap">
  <h1>Christmas Traditions</h1>
  <p class="sub">
    Click letters one at a time in a straight line (up, down, left, right, or diagonal),
    then click <b>Check</b>.
  </p>

  <div class="layout">
    <div id="grid" class="grid"></div>

    <aside class="side">
      <h2>Find these words</h2>
      <div id="chips" class="chips"></div>

      <div class="controls">
        <button id="checkBtn" class="primary">Check</button>
        <button id="clearBtn" class="secondary">Clear</button>
      </div>

      <div id="status" class="status">Found 0 of 0</div>
    </aside>
  </div>
</div>

<script>
/* ===== SETTINGS ===== */
const COLS = 14;
const ROWS = 11;

/* Christmas Traditions (keep <= 14 chars each) */
const WORDS = [
  "CAROLS",
  "NATIVITY",
  "MISTLETOE",
  "STOCKINGS",
  "ORNAMENT",
  "PRESENTS",
  "LIGHTS",
  "CANDLES",
  "COOKIES",
  "SANTA",
  "WREATH",
  "TREE"
];

/* Wednesday */
const SEED_STRING = "2025-12-24-Z"; // <- aggressive seed (change letter if you want a totally different layout)

/* ===== STRONGER BIAS (SAFE) ===== */
const MAX_LTR = 2;       // cap easy left-to-right placements
const MIN_DIAGONAL = 4;  // insist on diagonals being present

/* ===== SEEDED RNG ===== */
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i=0;i<str.length;i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h<<13) | (h>>>19);
  }
  return function(){
    h = Math.imul(h ^ (h>>>16), 2246822507);
    h = Math.imul(h ^ (h>>>13), 3266489909);
    h ^= (h>>>16);
    return h>>>0;
  };
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t>>>15), t | 1);
    t ^= t + Math.imul(t ^ (t>>>7), t | 61);
    return ((t ^ (t>>>14))>>>0)/4294967296;
  };
}
const seedFn = xmur3(SEED_STRING);
let rand = mulberry32(seedFn());
const rInt = n => Math.floor(rand()*n);
const pick = a => a[rInt(a.length)];

/* ===== GRID GENERATOR ===== */
const DIRS = [
  {dx: 1, dy: 0, name:"LTR"},
  {dx:-1, dy: 0, name:"RTL"},
  {dx: 0, dy: 1, name:"DOWN"},
  {dx: 0, dy:-1, name:"UP"},
  {dx: 1, dy: 1, name:"D1"},
  {dx:-1, dy:-1, name:"D2"},
  {dx: 1, dy:-1, name:"D3"},
  {dx:-1, dy: 1, name:"D4"}
];

const LTR = DIRS[0];
const RTL = DIRS[1];
const VERT = [DIRS[2], DIRS[3]];
const DIAG = [DIRS[4], DIRS[5], DIRS[6], DIRS[7]];

const inB = (x,y)=>x>=0&&x<COLS&&y>=0&&y<ROWS;

function canPlace(g,w,x0,y0,d){
  for(let i=0;i<w.length;i++){
    const x=x0+d.dx*i, y=y0+d.dy*i;
    if(!inB(x,y)) return false;
    if(g[y][x] && g[y][x]!==w[i]) return false;
  }
  return true;
}

function placeWord(g,w,dirPool){
  for(let t=0;t<2200;t++){
    const d = pick(dirPool);
    const x = rInt(COLS), y = rInt(ROWS);
    if(!canPlace(g,w,x,y,d)) continue;
    for(let i=0;i<w.length;i++){
      g[y+d.dy*i][x+d.dx*i] = w[i];
    }
    return d;
  }
  return null;
}

function findWord(g,w){
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      for(const d of DIRS){
        let ok=true;
        for(let i=0;i<w.length;i++){
          const xx=x+d.dx*i, yy=y+d.dy*i;
          if(!inB(xx,yy)||g[yy][xx]!==w[i]){ok=false;break;}
        }
        if(ok) return true;
      }
    }
  }
  return false;
}

/* weighted dir pool = more diagonals, fewer LTR */
function buildDirPool(ltrUsed){
  const pool = [];

  // Strong diagonal bias: 8 diagonal entries
  for(let i=0;i<8;i++) pool.push(pick(DIAG));

  // Vertical bias: 5 vertical entries
  for(let i=0;i<5;i++) pool.push(pick(VERT));

  // Some RTL: 3 entries
  for(let i=0;i<3;i++) pool.push(RTL);

  // Limited LTR: only if still under cap
  if(ltrUsed < MAX_LTR){
    pool.push(LTR); // 1 entry only
  }

  return pool;
}

function generate(words){
  rand = mulberry32(seedFn());
  const sorted = [...words].sort((a,b)=>b.length-a.length);

  for(let attempt=0; attempt<900; attempt++){
    const g = Array.from({length:ROWS},()=>Array(COLS).fill(""));
    let ltrCount = 0;
    let diagCount = 0;

    let success = true;

    for(const w of sorted){
      const pool = buildDirPool(ltrCount);
      const d = placeWord(g, w, pool);
      if(!d){ success=false; break; }

      if(d.dx===1 && d.dy===0) ltrCount++;
      if(Math.abs(d.dx)===1 && Math.abs(d.dy)===1) diagCount++;
    }

    if(!success) continue;

    const filler="EAIONRSTLUAENRSTL";
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(!g[y][x]) g[y][x]=filler[rInt(filler.length)];
      }
    }

    if(!words.every(w=>findWord(g,w))) continue;
    if(ltrCount > MAX_LTR) continue;
    if(diagCount < MIN_DIAGONAL) continue;

    return g;
  }

  throw new Error("Grid failed (try changing SEED_STRING).");
}

/* ===== UI ===== */
const WORDSET = WORDS.map(w=>w.toUpperCase());
const gridData = generate(WORDSET);

const gridEl=document.getElementById("grid");
const chipsEl=document.getElementById("chips");
const statusEl=document.getElementById("status");

let selected=[], locked=null, found=new Set();

gridEl.style.gridTemplateColumns=`repeat(${COLS}, var(--tile))`;

gridData.forEach((row,y)=>{
  row.forEach((l,x)=>{
    const d=document.createElement("div");
    d.className="tile";
    d.textContent=l;
    d.onclick=()=>tap(x,y,d);
    gridEl.appendChild(d);
  });
});

WORDSET.forEach(w=>{
  const c=document.createElement("div");
  c.className="chip";
  c.textContent=w;
  c.id="w-"+w;
  chipsEl.appendChild(c);
});

statusEl.textContent=`Found 0 of ${WORDSET.length}`;

function step(a,b){
  const dx=b.x-a.x, dy=b.y-a.y;
  if(Math.abs(dx)>1||Math.abs(dy)>1||(!dx&&!dy)) return null;
  return {dx:Math.sign(dx),dy:Math.sign(dy)};
}

function tap(x,y,el){
  if(selected.length){
    const last=selected[selected.length-1];
    if(last.x===x&&last.y===y){
      el.classList.remove("sel");
      selected.pop();
      if(selected.length<2) locked=null;
      return;
    }
  }
  if(selected.some(s=>s.x===x&&s.y===y)) return;

  if(!selected.length){
    selected.push({x,y,el});
    el.classList.add("sel");
    return;
  }
  if(selected.length===1){
    const s=step(selected[0],{x,y});
    if(!s) return;
    locked=s;
  } else {
    const s=step(selected[selected.length-1],{x,y});
    if(!s||s.dx!==locked.dx||s.dy!==locked.dy) return;
  }
  selected.push({x,y,el});
  el.classList.add("sel");
}

document.getElementById("checkBtn").onclick=()=>{
  if(selected.length<2) return;
  const str=selected.map(s=>gridData[s.y][s.x]).join("");
  const rev=str.split("").reverse().join("");
  const hit=WORDSET.find(w=>!found.has(w)&&(w===str||w===rev));
  if(!hit) return;

  found.add(hit);
  selected.forEach(s=>s.el.classList.add("found"));
  document.getElementById("w-"+hit).classList.add("found");
  statusEl.textContent=`Found ${found.size} of ${WORDSET.length}`;

  selected=[]; locked=null;
};

document.getElementById("clearBtn").onclick=()=>{
  selected.forEach(s=>s.el.classList.remove("sel"));
  selected=[]; locked=null;
};
</script>
</body>
</html>
