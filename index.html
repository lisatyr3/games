<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Holiday Word Search</title>
  <style>
    :root{
      --tile: 46px;
      --gap: 10px;
      --border:#d9d9d9;
      --text:#111;
      --muted:#666;
      --selected:#cfe8ff;
      --found:#bfe6c6;
      --chip:#f6f6f6;
      --chip-border:#dcdcdc;
      --btn:#e9e9e9;
      --btnText:#111;
      --btnPrimary:#bfe6c6;
    }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      margin:0;
      padding:28px 18px;
      background:#fff;
    }
    h1{ margin:0 0 6px; font-size:44px; letter-spacing:-0.5px; }
    .sub{ margin:0 0 18px; color:var(--muted); font-size:18px; line-height:1.35; }

    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      display:flex;
      gap:26px;
      align-items:flex-start;
    }

    .board{
      flex: 1 1 auto;
      min-width: 320px;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(14, var(--tile));
      gap: var(--gap);
      align-items:center;
      justify-content:start;
      user-select:none;
    }

    .cell{
      width:var(--tile);
      height:var(--tile);
      border:1px solid var(--border);
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      font-size:20px;
      background:#fff;
      cursor:pointer;
      transition: transform 0.03s ease, background 0.12s ease;
    }
    .cell:active{ transform: scale(0.98); }

    /* Found letters stay green, even if re-used later */
    .cell.found{ background: var(--found); }

    /* Selected letters are blue; if a found letter is selected, it becomes blue while selected */
    .cell.selected{ background: var(--selected) !important; }

    .side{
      width: 320px;
      flex: 0 0 320px;
    }

    .side h2{
      margin:6px 0 12px;
      font-size:30px;
      letter-spacing:-0.3px;
    }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-bottom:14px;
    }
    .chip{
      background: var(--chip);
      border:1px solid var(--chip-border);
      border-radius:999px;
      padding:10px 14px;
      font-weight:800;
      font-size:16px;
      line-height:1;
      color:#111;
    }
    .chip.found{
      background: var(--found);
      border-color: #9fd2a7;
    }

    .controls{
      display:flex;
      gap:12px;
      align-items:center;
      margin: 10px 0 14px;
      flex-wrap:wrap;
    }
    button{
      border:0;
      border-radius:10px;
      padding:12px 16px;
      font-size:16px;
      font-weight:700;
      background: var(--btn);
      color: var(--btnText);
      cursor:pointer;
    }
    button.primary{ background: var(--btnPrimary); }
    button:active{ transform: translateY(1px); }

    .status{
      margin-top:6px;
      font-size:20px;
      font-weight:800;
    }

    .note{
      margin-top:10px;
      color:var(--muted);
      font-size:14px;
      line-height:1.35;
    }

    /* Responsive: stack sidebar under grid on small screens */
    @media (max-width: 980px){
      .wrap{ flex-direction:column; }
      .side{ width:100%; flex: 1 1 auto; }
      .grid{ justify-content:center; }
    }

    /* Tighten tiles a bit on very small screens */
    @media (max-width: 520px){
      :root{ --tile: 38px; --gap: 8px; }
      h1{ font-size:36px; }
      .side h2{ font-size:26px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="board">
      <h1>Holiday Word Search</h1>
      <p class="sub">
        Click letters one at a time to spell a word in a straight line
        (up, down, left, right, or diagonal). Then click <b>Check</b>.
      </p>

      <div id="grid" class="grid" aria-label="Word search grid"></div>
    </div>

    <aside class="side">
      <h2>Find these words</h2>

      <div id="chips" class="chips"></div>

      <div class="controls">
        <button id="checkBtn" class="primary" type="button">Check</button>
        <button id="clearBtn" type="button">Clear</button>
      </div>

      <div id="status" class="status">Found 0 of 12</div>
      <div class="note">Tip: You can re-use letters that are part of an already-found word.</div>
    </aside>
  </div>

<script>
  // 14 columns x 11 rows (each row must be EXACTLY 14 letters)
  const gridData = [
    "HWLOWPKSASYXCX",
    "GLOUVRWLCAZRMG",
    "INOGPGEIKNJKRS",
    "EHERSPIAZTKVYB",
    "LOBDAUZFTAOADF",
    "SLEONCOOTHANGW",
    "ELUJCFICUSLICL",
    "VYUOFBMUSEVLEJ",
    "XWCYHNUCWONSWD",
    "AOGREINDEERPCE",
    "ASHTINSELQVOAA"
  ];

  const words = [
    "SANTA","REINDEER","ELVES","SNOW","NOEL","CAROL",
    "TINSEL","HOLLY","WREATH","GIFTS","SLEIGH","COCOA"
  ];

  const ROWS = gridData.length;
  const COLS = gridData[0].length;

  const gridEl = document.getElementById("grid");
  const chipsEl = document.getElementById("chips");
  const statusEl = document.getElementById("status");
  const checkBtn = document.getElementById("checkBtn");
  const clearBtn = document.getElementById("clearBtn");

  // State
  const foundWords = new Set();
  const foundCells = new Set();   // "r,c" for green cells
  let selected = [];              // array of {r,c}
  let direction = null;           // {dr,dc} once established

  function key(r,c){ return r + "," + c; }
  function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
  function letterAt(r,c){ return gridData[r].charAt(c); }

  function renderGrid(){
    gridEl.innerHTML = "";
    gridEl.style.gridTemplateColumns = `repeat(${COLS}, var(--tile))`;

    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const btn = document.createElement("div");
        btn.className = "cell";
        btn.textContent = letterAt(r,c);
        btn.dataset.r = r;
        btn.dataset.c = c;

        const k = key(r,c);
        if(foundCells.has(k)) btn.classList.add("found");

        btn.addEventListener("click", () => onCellClick(r,c));
        gridEl.appendChild(btn);
      }
    }

    syncSelectedClasses();
  }

  function renderChips(){
    chipsEl.innerHTML = "";
    words.forEach(w=>{
      const chip = document.createElement("div");
      chip.className = "chip" + (foundWords.has(w) ? " found" : "");
      chip.textContent = w;
      chipsEl.appendChild(chip);
    });
  }

  function syncSelectedClasses(){
    const selectedSet = new Set(selected.map(p=>key(p.r,p.c)));
    const cells = gridEl.querySelectorAll(".cell");
    cells.forEach(cell=>{
      const r = Number(cell.dataset.r);
      const c = Number(cell.dataset.c);
      const k = key(r,c);
      cell.classList.toggle("selected", selectedSet.has(k));
      cell.classList.toggle("found", foundCells.has(k));
    });
  }

  // Allow deselecting ONLY the last clicked tile (simple + senior-friendly)
  function popIfLast(r,c){
    if(selected.length === 0) return false;
    const last = selected[selected.length-1];
    if(last.r === r && last.c === c){
      selected.pop();
      if(selected.length < 2) direction = null;
      return true;
    }
    return false;
  }

  function adjacentStep(a,b){
    const dr = b.r - a.r;
    const dc = b.c - a.c;
    if(dr === 0 && dc === 0) return null;
    if(Math.abs(dr) > 1 || Math.abs(dc) > 1) return null;
    return { dr: Math.sign(dr), dc: Math.sign(dc) };
  }

  function onCellClick(r,c){
    // toggle off last
    if(popIfLast(r,c)){
      syncSelectedClasses();
      return;
    }

    // prevent selecting the same cell twice (unless it's last to deselect)
    if(selected.some(p=>p.r===r && p.c===c)) return;

    if(selected.length === 0){
      selected.push({r,c});
      direction = null;
      syncSelectedClasses();
      return;
    }

    if(selected.length === 1){
      const step = adjacentStep(selected[0], {r,c});
      if(!step) return; // must be adjacent
      direction = step;
      selected.push({r,c});
      syncSelectedClasses();
      return;
    }

    // length >= 2: must keep same direction and be next to the last cell
    const last = selected[selected.length-1];
    const step = adjacentStep(last, {r,c});
    if(!step) return;

    if(step.dr !== direction.dr || step.dc !== direction.dc) return;

    selected.push({r,c});
    syncSelectedClasses();
  }

  function getSelectedString(){
    return selected.map(p=>letterAt(p.r,p.c)).join("");
  }

  function checkSelection(){
    if(selected.length < 2) return;

    const s1 = getSelectedString();
    const s2 = s1.split("").reverse().join("");

    // match any not-yet-found word
    const match = words.find(w => !foundWords.has(w) && (w === s1 || w === s2));
    if(!match) return;

    foundWords.add(match);

    // mark cells as found (green) BUT they remain clickable for intersecting words
    selected.forEach(p => foundCells.add(key(p.r,p.c)));

    // clear selection
    selected = [];
    direction = null;

    renderChips();
    syncSelectedClasses();
    updateStatus();
  }

  function clearSelection(){
    selected = [];
    direction = null;
    syncSelectedClasses();
  }

  function updateStatus(){
    statusEl.textContent = `Found ${foundWords.size} of ${words.length}`;
  }

  checkBtn.addEventListener("click", checkSelection);
  clearBtn.addEventListener("click", clearSelection);

  // Init
  renderGrid();
  renderChips();
  updateStatus();
</script>
</body>
</html>
